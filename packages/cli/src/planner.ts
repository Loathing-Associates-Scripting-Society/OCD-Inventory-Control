import {CleanupRule, StockingRule} from '@philter/common';
import {
  isCleanable,
  logger,
  ReadonlyCleanupRules,
  ReadonlyStockingRules,
  toItemMap,
} from '@philter/common/kol';
import {
  availableAmount,
  closetAmount,
  creatableAmount,
  getInventory,
  getProperty,
  haveDisplay,
  itemAmount,
  myPath,
  retrieveItem,
  toBoolean,
  toItem,
  userConfirm,
} from 'kolmafia';
import {getvar} from 'zlib.ash';
import {countIngredient, fullAmount} from './util';

/**
 * Cleanup execution plan generated by examining OCD data and the player's
 * inventory, closet, storage, etc.
 */
export interface CleanupPlan {
  /** Items to break apart. */
  brak: Map<Item, number>;
  /** Items to transform into other items. */
  make: Map<Item, number>;
  /** Items to untinker. */
  untink: Map<Item, number>;
  /** Items to use. */
  usex: Map<Item, number>;
  /** Items to pulverize. */
  mall: Map<Item, number>;
  /** Items to autosell. */
  auto: Map<Item, number>;
  /** Items to discard. */
  disc: Map<Item, number>;
  /** Items to put in the display case. */
  disp: Map<Item, number>;
  /** Items to put in the closet. */
  clst: Map<Item, number>;
  /** Items to put in the clan stash. */
  clan: Map<Item, number>;
  /** Items to display reminder message(s). */
  todo: Map<Item, number>;
  /**
   * Items to send to another player.
   * Maps target player name => item => quantity.
   */
  gift: Map<string, Map<Item, number>>;

  /**
   * Intermediate cache that stores how many of an item is consumed by a
   * transformation recipe ("MAKE" action).
   * For example, if the OCD action for the 'bar skin' is "MAKE" and the
   * target item is a 'barskin tent', then this map will contain
   * 'bar skin' => 1. If the OCD configuration for the 'spider web' is
   * "MAKE" and the target item is a 'really really sticky spider web',
   * then this map will contain 'spider web' => 4.
   */
  make_q: Map<Item, number>;
}

/**
 * Computes the actual amount of `item` to clean up based on its cleanup and
 * stocking rules.
 * This considers equipment in terrarium (but not equipped) for cleanup.
 * @param item Item to check
 * @param cleanupRule Cleanup rule for the item
 * @param stockingRule Stocking rule for the item, if any
 * @return Amount of the item to cleanup
 */
export function ocd_amount(
  item: Item,
  cleanupRule: Readonly<CleanupRule>,
  stockingRule: Readonly<StockingRule> | undefined
): number {
  if (cleanupRule.action === 'KEEP') return 0;
  const full = fullAmount(item);
  // Unequip item from terrarium or equipment if necessary to OCD it.
  const keepAmount = cleanupRule.keepAmount || 0;
  if (full > keepAmount && availableAmount(item) > itemAmount(item)) {
    retrieveItem(Math.min(full - keepAmount, availableAmount(item)), item);
  }
  // Don't OCD items that are part of stock. Stock can always be satisfied by closet.
  const keep =
    getvar('BaleOCD_Stock') === '0'
      ? keepAmount
      : Math.max(
          keepAmount,
          (stockingRule?.amount || 0) -
            (getProperty('autoSatisfyWithCloset') === 'false'
              ? 0
              : closetAmount(item))
        );
  // OCD is limited by itemAmount(it) since we don't want to purchase anything and closeted items
  // may be off-limit, but if there's something in the closet, it counts against the amount you own.
  return Math.min(full - keep, itemAmount(item));
}

export class CleanupPlanner {
  // When malling dangerously, don't ask the user about uncategorized items
  shouldAskAboutUncategorizedItems = !toBoolean(
    getvar('BaleOCD_MallDangerously')
  );

  // Don't stop if "don't ask user" or it is a quest item, or it is being stocked.
  checkStopForRelay(item: Item, stockingRules: ReadonlyStockingRules): boolean {
    if (!this.shouldAskAboutUncategorizedItems || !isCleanable(item)) {
      return false;
    }
    // If we need to stock up on the item, don't bother the user about it
    const stockingRule = stockingRules.get(item);
    if (stockingRule && fullAmount(item) <= stockingRule.amount) {
      return false;
    }

    if (
      userConfirm(
        'Uncategorized item(s) have been found in inventory.\nAbort to categorize those items with the relay script?'
      )
    ) {
      throw new Error(
        'Please use the relay script to categorize missing items in inventory.'
      );
    }
    this.shouldAskAboutUncategorizedItems = false;
    return false;
  }

  /**
   * Examines the inventory and generates an appropriate execution plan.
   * If it finds uncategorized items in inventory, it asks the user whether it
   * should abort. If the user answers "No", it will not ask the user again
   * within the current `ocd_control()` call.
   * @param cleanupRules Map containing OCD rules
   * @param stockingRules Map containing stocking rules
   * @return `true` if the user chose to continue, or was not asked at all
   *      (i.e. there were no uncategorized items).
   *      `false` if the user chose to abort.
   */
  makePlan(
    cleanupRules: ReadonlyCleanupRules,
    stockingRules: ReadonlyStockingRules
  ): CleanupPlan | null {
    const plan: CleanupPlan = {
      brak: new Map<Item, number>(),
      make: new Map<Item, number>(),
      untink: new Map<Item, number>(),
      usex: new Map<Item, number>(),
      mall: new Map<Item, number>(),
      auto: new Map<Item, number>(),
      disc: new Map<Item, number>(),
      disp: new Map<Item, number>(),
      clst: new Map<Item, number>(),
      clan: new Map<Item, number>(),
      todo: new Map<Item, number>(),
      gift: new Map<string, Map<Item, number>>(),
      make_q: new Map<Item, number>(),
    };

    let excess = 0;
    for (const doodad of toItemMap(getInventory()).keys()) {
      const rule = cleanupRules.get(doodad);
      if (rule) {
        excess = ocd_amount(doodad, rule, stockingRules.get(doodad));
        if (excess > 0)
          switch (rule.action) {
            case 'BREAK':
              plan.brak.set(doodad, excess);
              break;
            case 'MAKE': {
              const target = toItem(rule.targetItem);
              const used_per_craft = countIngredient(doodad, target);
              plan.make_q.set(doodad, used_per_craft);
              if (used_per_craft === 0) {
                logger.error(
                  `You cannot transform an ${doodad} into a ${rule.targetItem}. There's a problem with your data file or your crafting ability.`
                );
                break;
              }
              let use_qty = excess;
              if (used_per_craft > 1) {
                use_qty = use_qty - (use_qty % used_per_craft);
              }

              if (rule.shouldUseCreatableOnly) {
                use_qty = Math.min(
                  use_qty,
                  creatableAmount(target) * used_per_craft
                );
              }
              if (use_qty !== 0) plan.make.set(doodad, use_qty);
              break;
            }
            case 'UNTN':
              plan.untink.set(doodad, excess);
              break;
            case 'USE':
              if (myPath() === 'Bees Hate You' && doodad.name.includes('b'))
                break;
              plan.usex.set(doodad, excess);
              break;
            case 'PULV':
              // No-op since act_pulverize() does its own logging
              break;
            case 'MALL':
              plan.mall.set(doodad, excess);
              break;
            case 'AUTO':
              plan.auto.set(doodad, excess);
              break;
            case 'DISC':
              plan.disc.set(doodad, excess);
              break;
            case 'DISP':
              if (haveDisplay()) plan.disp.set(doodad, excess);
              // else KEEP
              break;
            case 'CLST':
              plan.clst.set(doodad, excess);
              break;
            case 'CLAN':
              plan.clan.set(doodad, excess);
              break;
            case 'GIFT': {
              let giftMap = plan.gift.get(rule.recipent);
              if (!giftMap) {
                plan.gift.set(rule.recipent, (giftMap = new Map()));
              }
              giftMap.set(doodad, excess);
              break;
            }
            case 'TODO':
              plan.todo.set(doodad, excess);
              break;
            case 'KEEP':
              break;
            default:
              if (this.checkStopForRelay(doodad, stockingRules)) return null;
          }
      } else {
        if (this.checkStopForRelay(doodad, stockingRules)) return null;
        // Potentially disasterous, but this will cause the script to sell off unlisted items, just like it used to.
        if (toBoolean(getvar('BaleOCD_MallDangerously')))
          plan.mall.set(doodad, excess); // Backwards compatibility FTW!
      }
    }
    return plan;
  }
}
