import { CleanupAction, CleanupRule, CleanupRuleset, StockingRule } from "@philter/common";
import { loadCleanupRulesetFile, toItemMap } from "@philter/common/kol";
import { abort, autosell, autosellPrice, availableAmount, batchClose, batchOpen, canEquip, canInteract, cliExecute, closetAmount, count, creatableAmount, create, equip, equippedAmount, getInventory, getProperty, getRelated, haveDisplay, haveSkill, historicalAge, historicalPrice, isInteger, isOnline, isTradeable, itemAmount, mallPrice, max, min, myClass, myName, myPath, myPrimestat, print, putCloset, putShop, retrieveItem, setProperty, shopAmount, shopPrice, storageAmount, toBoolean, toInt, toItem, toSlot, use, userConfirm, visitUrl } from "kolmafia";
import {getvar, kmail, rnum, vprint} from 'zlib.ash';
import { countIngredient, fullAmount, get_malus_order, is_OCDable, other_clover, sauce_mult, split_items_sorted } from "./util";


/**
 * Loads cleanup rules from the player's cleanup ruleset file into a map.
 * This will look for a ruleset file whose name is stored in the
 * `BaleOCD_DataFile` property. If this fails, it uses the current player's name
 * as a fallback.
 *
 * @param extraRulesetFile If this is not an empty string, this specifies the
 * 			name of the text file (without the ".txt") to load extra cleanup rules
 * 			from.
 *      These cleanup rules will be merged with the user's ruleset, with the
 * 			user's rules taking priority.
 * @return The loaded and combined cleanup ruleset
 */
	function load_OCD(extraRulesetFile?: string) {
	const cleanupRules = loadCleanupRulesetFile(`OCDdata_${getvar("BaleOCD_DataFile")}.txt`) || loadCleanupRulesetFile(`OCD_${myName()}_Data.txt`)
	if (
		!cleanupRules
	) {
		throw new Error("Something went wrong trying to load OCDdata!");
	}

	if (extraRulesetFile) {
		// Merge extra cleanup ruleset
		const extraCleanupRules = loadCleanupRulesetFile(`${extraRulesetFile}.txt`);
		if (extraCleanupRules) {
			for (const [item, rule] of extraCleanupRules) {
				if (!cleanupRules.has(item)) cleanupRules.set(item, rule);
			}
		}
	}

	if (cleanupRules.size === 0) {
		throw new Error("All item information is corrupted or missing. Whoooah! I hope you didn't lose any data...");
	}
	return cleanupRules;
}

/**
 * Sale price cache for the MALL action.
 * This cache is populated by `print_cat()` with values returned by
 * `sale_price()`. Later, it is accessed by `act_cat()`. This ensures that the
 * sale price displayed to the user matches the actual sale price used.
 * Note that this cache is never used when sending items to a mall multi.
*/
const price = new Map<Item, number>();


/**
 * Computes an appropriate selling price for an item at the mall, based on its
 * current (or historical) mall price.
 * @param it Item to check
 * @param minPrice Minimum price
 * @return Appropriate selling price for the item, or zero if the item is not
 *		available in the mall.
 *		The returned price is guaranteed to be at least 0.
 */
function sale_price(it: Item, minPrice: number): number {
	let price = 0;
	if(historicalAge(it) < 1 && historicalPrice(it) > 0)
		price = historicalPrice(it);
	else price = mallPrice(it);
	return Math.max(minPrice, price, 0);
}

// Amount to OCD. Consider equipment in terrarium (but not equipped) as OCDable.
function ocd_amount(it: Item, action: CleanupAction, keepAmount: number, stock): number {
	if(action === "KEEP") return 0;
	const full = fullAmount(it);
	// Unequip item from terrarium or equipment if necessary to OCD it.
	if(full > keepAmount && availableAmount(it) > itemAmount(it))
		retrieveItem(Math.min(full - keepAmount, availableAmount(it)), it);
	// Don't OCD items that are part of stock. Stock can always be satisfied by closet.
	const keep = getvar("BaleOCD_Stock") === "0" ? keepAmount:
		Math.max(keepAmount, stock[it].q - (getProperty("autoSatisfyWithCloset") === "false"? 0: closetAmount(it)));
	// OCD is limited by itemAmount(it) since we don't want to purchase anything and closeted items
	// may be off-limit, but if there's something in the closet, it counts against the amount you own.
	return Math.min(full - keep, itemAmount(it));
}

/**
 * Cleanup execution plan generated by examining OCD data and the player's
 * inventory, closet, storage, etc.
 */
	interface CleanupPlan {
	/** Items to break apart. */
		brak: Map<Item, number>;
	/** Items to transform into other items. */
		make: Map<Item, number>;
	/** Items to untinker. */
		untink: Map<Item, number>;
	/** Items to use. */
		usex: Map<Item, number>;
	/** Items to pulverize. */
		mall: Map<Item, number>;
	/** Items to autosell. */
		auto: Map<Item, number>;
	/** Items to discard. */
		disc: Map<Item, number>;
	/** Items to put in the display case. */
		disp: Map<Item, number>;
	/** Items to put in the closet. */
		clst: Map<Item, number>;
	/** Items to put in the clan stash. */
		clan: Map<Item, number>;
	/** Items to display reminder message(s). */
		todo: Map<Item, number>;
	/**
	 * Items to send to another player.
	 * Maps target player name => item => quantity.
	 */
	gift: Map<string, Map<Item, number>>;

	/**
	 * Intermediate cache that stores how many of an item is consumed by a
	 * transformation recipe ("MAKE" action).
	 * For example, if the OCD action for the 'bar skin' is "MAKE" and the
	 * target item is a 'barskin tent', then this map will contain
	 * 'bar skin' => 1. If the OCD configuration for the 'spider web' is
	 * "MAKE" and the target item is a 'really really sticky spider web',
	 * then this map will contain 'spider web' => 4.
	 */
	make_q: Map<Item, number>;
};

function create_it(it: Item, obj: Item, quant: number, make_quant: number): boolean {
	if (make_quant === 0) return false;
	quant = quant / make_quant * sauce_mult(it);
	if(quant > 0) return create(quant, obj);
	return false;
}

function use_it(quant: number, it: Item): boolean {
	function use_map(required: Item): boolean {
		cliExecute("checkpoint");
		if(required === Item.get(`none`))
			cliExecute("maximize stench resistance, 1 min");
		else {
			retrieveItem(1, required);
			equip(required);
		}
		const success = use(1, it);
		cliExecute("outfit checkpoint");
		return success;
	}

	switch(it) {
	case Item.get(`the Slug Lord's map`):
		return use_map(Item.get(`none`));
	case Item.get(`Dr. Hobo's map`):{
		const whip = Item.get(['Bar whip', 'Bat whip', 'Clown whip', 'Demon whip', 'Dishrag', 'Dreadlock whip', 'Gnauga hide whip',
			'Hippo whip', 'Palm-frond whip', 'Penguin whip', 'Rattail whip', 'Scorpion whip', 'Tail o\' nine cats', 'White whip',
			'Wumpus-hair whip', 'Yak whip']).find(it => itemAmount(it) && canEquip(it)) || Item.get(`cool whip`);
		retrieveItem(1, Item.get(`asparagus knife`));
		return use_map(whip);}
	case Item.get(`Dolphin King's map`):{
		const breather = Item.get(['aerated diving helmet', 'makeshift SCUBA gear']).find(it => itemAmount(it) && canEquip(it)) || Item.get(`snorkel`);
		return use_map(breather);}
	case Item.get(`Degrassi Knoll shopping list`):
		if(itemAmount(Item.get(`bitchin' meatcar`)) === 0)
			return false;
		break;
	}
	return use(quant, it);
}

// StopForMissingItems is a parameter in case someone wants to include this script.
// StopForMissingItems = FALSE to prevent a pop-up confirmation.
export function ocd_control(shouldStopForMissingItems: boolean, extraData = '') {
	let FinalSale = 0;

	record {
		string type;
		int q;
	} [item] stock;

	// Save these so they can be screwed with safely
	let autoSatisfyWithCloset = toBoolean(getProperty("autoSatisfyWithCloset"));
	let autoSatisfyWithStorage = toBoolean(getProperty("autoSatisfyWithStorage"));
	let autoSatisfyWithStash = toBoolean(getProperty("autoSatisfyWithStash"));

	let use_multi = getvar("BaleOCD_MallMulti") !== "" && toBoolean(getvar("BaleOCD_UseMallMulti"));

	const command = Object.freeze({
		BREAK:  "break apart ",
MAKE:  "transform ",
UNTN:  "untinker ",
USE:  "use ",
PULV:  "pulverize ", // Not used, "pulverize" is hardcoded now
MALL: use_multi ?  `send to mallmulti ${getvar("BaleOCD_MallMulti")}: ` : "mallsell ",
AUTO:  "autosell ",
DISC:  "discard ",
DISP:  "display ",
CLST:  "closet ",
CLAN:  "stash put ",
GIFT:  "send gift to ",
	});

	/**
	 * Once this has been set to `false`, it will be `false` for all successive
	 * calls to the function
	 */
	let AskUser = true;

	/**
	 * Examines the inventory and generates an appropriate execution plan.
	 * If it finds uncategorized items in inventory, it asks the user whether it
	 * should abort. If the user answers "No", it will not ask the user again
	 * within the current `ocd_control()` call.
	 * @param StopForMissingItems If `false`, this function will never ask for
	 *      confirmation to proceed, even if there are uncategorized items.
	 * @param ocd_rules Map containing OCD rules
	 * @return `true` if the user chose to continue, or was not asked at all
	 *      (i.e. there were no uncategorized items).
	 *      `false` if the user chose to abort.
	 */
	function make_plan(
		StopForMissingItems: boolean, cleanupRules: ReadonlyMap<Item, CleanupRule>, stockingRules:ReadonlyMap<Item, StockingRule>
	): CleanupPlan | null {
		AskUser = AskUser && StopForMissingItems;
		// Don't stop if "don't ask user" or it is a quest item, or it is being stocked.
		function stop_for_relay(doodad: Item): boolean {
			if(!AskUser || !is_OCDable(doodad)) {return false;}
			const stockingRule = stockingRules.get(doodad);
			if (stockingRule && fullAmount(doodad) <= stockingRule.amount) {
				return false;
			}
			if(userConfirm("Uncategorized item(s) have been found in inventory.\nAbort to categorize those items with the relay script?")) {
				throw new Error("Please use the relay script to categorize missing items in inventory.");
			}
			AskUser = false;
			return false;
		}

		const plan: CleanupPlan = {
			 brak: new Map<Item, number>(),
			 make: new Map<Item, number>(),
			 untink: new Map<Item, number>(),
			 usex: new Map<Item, number>(),
			 mall: new Map<Item, number>(),
			 auto: new Map<Item, number>(),
			 disc: new Map<Item, number>(),
			 disp: new Map<Item, number>(),
			 clst: new Map<Item, number>(),
			 clan: new Map<Item, number>(),
			 todo: new Map<Item, number>(),
			gift: new Map<string, Map<Item, number>>(),
			make_q: new Map<Item, number>()
		};

		let excess = 0;
		for (const doodad of toItemMap(getInventory()).keys()) {
			const rule = cleanupRules.get(doodad);
			if(rule) {
				excess = ocd_amount(doodad, rule.action, rule.keepAmount);
				if(excess > 0)
					switch(rule.action) {
					case "BREAK":
						plan.brak.set(doodad, excess);
						break;
					case "MAKE": {
						const target = toItem(rule.targetItem);
						const used_per_craft = countIngredient(doodad, target
						);
						plan.make_q.set(doodad, used_per_craft);
						if (used_per_craft === 0) {
							vprint(
								`You cannot transform an ${doodad} into a ${rule.targetItem}. There's a problem with your data file or your crafting ability.`,
								_ocd_color_error(),
								-3
							);
							break;
						}
						let use_qty = excess;
						if (used_per_craft > 1) {
							use_qty = use_qty - (use_qty % used_per_craft);
						}

						if (rule.shouldUseCreatableOnly) {
							use_qty = Math.min(
								use_qty,
								creatableAmount(target) * used_per_craft
							);
						}
						if (use_qty !== 0) plan.make.set(doodad, use_qty);
						break;
					}
					case "UNTN":
						plan.untink.set(doodad, excess);
						break;
					case "USE":
						if(myPath() === "Bees Hate You" && doodad.name.includes("b"))
							break;
						plan.usex.set(doodad, excess);
						break;
					case "PULV":
						// No-op since act_pulverize() does its own logging
						break;
					case "MALL":
						plan.mall.set(doodad, excess);
						break;
					case "AUTO":
						plan.auto.set(doodad, excess);
						break;
					case "DISC":
						plan.disc.set(doodad, excess);
						break;
					case "DISP":
						if(haveDisplay())
							plan.disp.set(doodad, excess);
						// else KEEP
						break;
					case "CLST":
						plan.clst.set(doodad, excess);
						break;
					case "CLAN":
						plan.clan.set(doodad, excess);
						break;
					case "GIFT":{
						let giftMap = plan.gift.get(rule.recipent);
						if (!giftMap) {
							plan.gift.set(rule.recipent, giftMap = new Map());
						}
						giftMap.set(doodad, excess);
						break;}
					case "TODO":
						plan.todo.set(doodad, excess);
						break;
					case "KEEP":
						break;
					default:
						if(stop_for_relay(doodad))
							return null;
					}
			} else {
				if(stop_for_relay(doodad))
					return null;
				// Potentially disasterous, but this will cause the script to sell off unlisted items, just like it used to.
				if(toBoolean(getvar("BaleOCD_MallDangerously")))
					plan.mall.set(doodad, excess);   // Backwards compatibility FTW!
			}
		}
		return plan;
	}

	function print_cat(cat: ReadonlyMap<Item, number>, rule: CleanupRule, cleanupRules: ReadonlyMap<Item, CleanupRule>): void {
		if(count(cat) < 1) return;

		const catOrder = new Map(Array.from(cat).sort(([itemA], [itemB]) => itemA.name.localeCompare(itemB.name)));

		let len = 0, total = 0, linevalue = 0;
		let queue = '';

		if (rule.action === 'KEEP' || rule.action === 'TODO') {throw new Error(`print_cat cannot process "${rule.action}" rule`);}
		let com = command[rule.action];
		if(rule.action === "GIFT") com += `${rule.recipent}: `;
		function print_line(): boolean {
			vprint(com + queue, _ocd_color_info(), 3);
			if (rule.action === "MALL"){
				vprint(`Sale price for this line: ${rnum(linevalue)}`, _ocd_color_info(), 3);
			}
			vprint(" ", 3);
			len = 0;
			total += linevalue;
			linevalue = 0;
			queue = ''
			return true;
		}

		for (const [it, quant] of catOrder) {
			if(it === Item.get(`Degrassi Knoll shopping list`) && itemAmount(Item.get(`bitchin' meatcar`)) === 0){
				continue;}
			if(len !== 0)
				queue+=(", ");
			queue+=(`${quant} ${it}`);
			if(rule.action === "MALL") {
				if(!use_multi) {
					price.set(it, sale_price(it, rule.minPrice));
					if(getvar("BaleOCD_Pricing") === "auto"){
						queue += ` @ ${rnum(price.get(it) || 0)}`;}
				}
				linevalue += quant * (price.get(it) || 0);
			} else if(rule.action === "MAKE") {
				queue += ` into ${rule.targetItem}`;
			} else if(rule.action === "AUTO") {
				linevalue += quant * autosellPrice(it);
			}
			len = len + 1;
			if(len === 11)
				print_line();
		}
		if(len > 0)
			print_line();

		if(rule.action === "MALL") {
			if(!use_multi){
				vprint(`Total mall sale = ${rnum(total)}`,_ocd_color_info(), 3);}
			// else vprint("Current mall price = "+rnum(total), _ocd_color_info(), 3);
		} else if(rule.action === "AUTO"){
			vprint("Total autosale = "+rnum(total), _ocd_color_info(), 3);}
		FinalSale += total;
	}

	// This is only called if the player has both kinds of clovers, so no need to check if stock contains both
	function clovers_needed(stockingRules: ReadonlyMap<Item, StockingRule>): number {
		return (stockingRules.get(Item.get(`ten-leaf clover`))?.amount || 0) + (stockingRules.get(Item.get(`disassembled clover`))?.amount || 0)
		  - fullAmount(Item.get(`ten-leaf clover`)) - fullAmount(Item.get(`disassembled clover`));
	}

	/**
	 * Stocks up on items based on the stock rules.
	 * @param ocd_rules OCD ruleset to use
	 * @return Whether all items were stocked successfully
	 */
	function stock(stockingRules: ReadonlyMap<Item, StockingRule>, cleanupRules: ReadonlyMap<Item, CleanupRule>) {
		let success = true;
		let first = true;
		function stockit(q: number, it: Item): boolean {
			q = q - closetAmount(it) - storageAmount(it) - equippedAmount(it);
			if(q < 1) return true;
			if(first) {
				vprint("Stocking up on required items!", _ocd_color_info(), 3);
				first = false;
			}
			return retrieveItem(q, it);
		}

		batchOpen();
		for (const [it, stockingRule] of stockingRules) {
			// Someone might want both assembled and disassembled clovers. Esure there are enough of combined tot
			if(Item.get(['ten-leaf clover','disassembled clover']).includes(it) && stockingRules.has(other_clover(it))) {
				const cloversNeededAmount = clovers_needed(stockingRules);
				if (cloversNeededAmount > 0) {
					cliExecute(`cheapest ten-leaf clover, disassembled clover; acquire ${cloversNeededAmount - availableAmount(it)} ${it}`);
				}
			}
			if(fullAmount(it) < stockingRule.amount && !stockit(stockingRule.amount, it)) {
				success = false;
				print(`Failed to stock ${(stockingRule.amount > 1? `${stockingRule.amount} ${it.plural}`: `a ${it}`)}`, _ocd_color_error());
			}
			// Closet everything (except for gear) that is stocked so it won't get accidentally used.
			const keepAmount = cleanupRules.get(it)?.keepAmount || 0;
			if(toSlot(it) === Slot.get('none') && stockingRule.amount - keepAmount > closetAmount(it) && itemAmount(it) > keepAmount)
				putCloset(min(itemAmount(it) - keepAmount, stockingRule.amount - keepAmount - closetAmount(it)), it);
		}
		batchClose();
		return success;
	}

	function getMessage(cat: ReadonlyMap<Item, number>, cleanupRules: ReadonlyMap<Item, CleanupRule>): string {
		for (const key of cat.keys()) {
			const rule = cleanupRules.get(key);
			if (rule && rule.action === 'GIFT') return rule.message;
		}
		// This should never happen in practice
		throw new Error('No message, wtf');
	}

	/**
	 * Process a collection of items using a given action.
	 * @param cat Collection of items and their amounts to be processed
	 * @param act Item action ID
	 * @param to Receiving player ID. Used for actions that involve another player
	 * 	  (e.g. "GIFT")
	 * @param plan OCD execution plan being used
	 * @param ocd_rules Map containing OCD rules
	 * @return Boolean that indicates whether the execution plan must be
	 *    regenerated before processing another action.
	 */
	function act_cat(
		cat: ReadonlyMap<Item, number>,
		act: CleanupAction,
		to: string,
		plan: CleanupPlan,
		cleanupRules: ReadonlyMap<Item, CleanupRule>
	): boolean {
		const catOrder = new Map(Array.from(cat).sort(([itemA], [itemB]) => itemA.name.localeCompare(itemB.name)));

		// If there are no items to process, we don't need to regenerate the
		// execution plan.
		if(cat.size === 0) return false;
		let i = 0;
		if (act === "TODO" && cat.size > 0)
			print("");
		else if (act === "PULV")
			abort("PULV action must be handled by act_pulverize()");
		else
			print_cat(cat, act, to, cleanupRules);
		if(toBoolean(getvar("BaleOCD_Sim"))) return true;

		switch(act) {
		case "MALL":
			if (use_multi) {
				const multi_id = getvar("BaleOCD_MallMulti");
				const multi_message = getvar("BaleOCD_MultiMessage");

				// Some users have reported OCD-Cleanup occasionally sending
				// items to an account named "False". While the exact cause is
				// unknown, this should serve as a stopgap measure.
				if (multi_id === "" || multi_id.to_lower_case() === "false") {
					print(
						`Invalid mall multi account ID ("{multi_id}"). Please report the issue at https://kolmafia.us/`,
						_ocd_color_error()
					);
					const timeout = 30;
					const warning_message =
						`OCD-Cleanup has detected that it is about to send items to a mall multi account named "{multi_id}". ` +
						`Since this is likely an error, OCD-Cleanup will NOT send the items.\n\n` +
						`Do you want to abort OCD-Cleanup immediately?\n` +
						`(If you choose "No" or wait {timeout} seconds, OCD-Cleanup will skip the MALL action and continue.)`;
					// If the user disables userConfirm() -- possibly because
					// they are calling OCD-Cleanup from an auto-adventuring
					// script -- it will always return false.
					// In this case, we will continue processing instead of
					// aborting (which would otherwise be disruptive).
					if (userConfirm(warning_message, timeout * 1000, false)) {
						abort(`You decided to abort OCD-Cleanup.`);
					}
					print(`OCD-Cleanup has skipped the MALL action.`);
					return false;
				} else {
					return kmail(multi_id, multi_message, 0, cat);
				}
			}
		case "AUTO":
		case "DISP":
		case "CLST":
		case "CLAN":
			batchOpen();
			break;
		case "GIFT": {
			const message = getMessage(cat, cleanupRules);
			return kmail(to, message, 0, cat, message);
		}
		}

		for (const [it, quant] of catOrder) {
			switch(act) {
			case "BREAK":
				for (let i = 1; i <= quant; ++i)
					visitUrl(`inventory.php?action=breakbricko&pwd&ajax=1&whichitem=${toInt(it)}`);
				break;
			case "MALL":
				if(getvar("BaleOCD_Pricing") === "auto") {
					const cachedPrice = price.get(it);
					// If price is -1, then there was an error.
					if(cachedPrice)  {
						putShop(cachedPrice, 0, quant, it);  // price[it] was found during print_cat()
					}
				} else{
					putShop((shopAmount(it)>0? shopPrice(it): 0), 0, quant, it);   // Set to max price of 999,999,999 meat
				}
				break;
			case "AUTO":
				autosell(quant, it);
				break;
			case "DISC":
				for (let i = 1; i <= quant; ++i) {
					if(i % 10 === 0){
						print(`Discarding ${i} of ${quant}...`);
					}
					visitUrl(`inventory.php?action=discard&pwd&ajax=1&whichitem=${toInt(it)}`);
				}
				break;
			case "USE":
				use_it(quant, it);
				break;
			case "MAKE":{
				const rule = cleanupRules.get(it);
				if ()
				create_it(
					it, toItem(cleanupRules.get(it).info), quant, plan.make_q[it]
				);
				break;}
			case "UNTN":
				cliExecute("untinker "+quant+" \u00B6"+ it.to_int());
				break;
			case "DISP":
				put_display(quant, it);
				break;
			case "CLST":
				putCloset(quant, it);
				break;
			case "CLAN":
				put_stash(quant, it);
				break;
			case "TODO":
				print_html("<b>"+it+" ("+quant+"): "+ocd_rules[it].info+"</b>");
				break;
			}
			i += 1;
			// If there are too many items batched mafia may run out of memory. On poor systems it usually happens around 20 transfers so stop at 15.
			if(i >= 165 && (act === "MALL" || act === "AUTO" || act === "DISP" || act === "CLST" || act === "CLAN")) {
				batchClose();
				i = 0;
				batchOpen();
			}
		}
		if(act === "MALL" || act === "AUTO" || act === "DISP"|| act === "CLST" || act === "CLAN") batchClose();

		// It's okay to return true here, because ocd_inventory() only checks
		// this value for actions that can create or remove additional items.
		return true;
	}

	void unequip_familiars() {
		matcher unequip = create_matcher("<a href='(familiar.php\\?pwd=.+?&action=unequip&famid=(.+?))'>\\[unequip\\]"
			, visitUrl("familiar.php"));
		while(unequip.find())
			switch(unequip.group(2)) {
			case "124": case "136": break;
			default:
				visitUrl(unequip.group(1));
			}
	}

	boolean ocd_inventory(boolean StopForMissingItems) {
		OCDinfo [item] ocd_rules;
		if (!load_OCD(ocd_rules, extraData)) return false;
		if((!file_to_map("OCDstock_"+getvar("BaleOCD_StockFile")+".txt", stock) || count(stock) === 0)
		  && getvar("BaleOCD_Stock") === "1") {
			print("You are missing item stocking information.", _ocd_color_error());
			return false;
		}

		MakePlanResult mpr = make_plan(StopForMissingItems, ocd_rules);
		if (!mpr.success) return false;

		// Actions that may create additional items, or remove items not
		// included in the execution plan. If act_cat() returns true after
		// executing such actions, the entire execution plan must be regenerated
		// to handle such items correctly.
		if (act_cat(mpr.plan.brak, "BREAK", "", mpr.plan, ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}
		if (act_cat(mpr.plan.make, "MAKE", "", mpr.plan, ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}
		if (act_cat(mpr.plan.untink, "UNTN", "", mpr.plan, ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}
		if (act_cat(mpr.plan.usex, "USE", "", mpr.plan, ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}
		// Note: Since the next action (act_pulverize()) does its own planning,
		// the previous if-block does not need to call make_plan().
		// I'm only keeping it to make refactoring/reordering easier.
		if (act_pulverize(ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}

		// Actions that never create or remove additional items.
		// Currently, we do not bother to check the return value of act_cat()
		// for them.
		act_cat(mpr.plan.mall, "MALL", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.auto, "AUTO", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.disc, "DISC", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.disp, "DISP", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.clst, "CLST", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.clan, "CLAN", "", mpr.plan, ocd_rules);
		foreach person in mpr.plan.gift {
			act_cat(mpr.plan.gift[person], "GIFT", person, mpr.plan, ocd_rules);
		}

		if(getvar("BaleOCD_Stock") === "1" && !getvar("BaleOCD_Sim").toBoolean())
			stock(ocd_rules);

		act_cat(mpr.plan.todo, "TODO", "", mpr.plan, ocd_rules);

		if(getvar("BaleOCD_Sim").toBoolean())
			vprint(
				"This was only a test. Had this been an actual OCD incident your inventory would be clean right now.",
				_ocd_color_success(),
				3
			);
		return true;
	}

// *******  Finally, here is the main for ocd_control()
// int ocd_control(boolean StopForMissingItems) {

	cliExecute("inventory refresh");

	// Empty closet before emptying out Hangks, otherwise it may interfere with which Hangk's items go to closet
	if(to_int(getvar("BaleOCD_EmptyCloset")) >= 0 && getProperty("lastEmptiedStorage").to_int() !== my_ascensions()
	  && getvar("BaleOCD_Sim") === "false")
		empty_closet();

	// Empty out Hangks, so it can be accounted for by what follows.
	if(autoSatisfyWithStorage && getProperty("lastEmptiedStorage").to_int() !== my_ascensions())
		 visitUrl("storage.php?action=pullall&pwd");

	boolean success;
	try {
		if(autoSatisfyWithCloset)
			setProperty("autoSatisfyWithCloset", "false");
		if(autoSatisfyWithStash)
			setProperty("autoSatisfyWithStash", "false");
		if(autoSatisfyWithStorage && getProperty("lastEmptiedStorage").to_int() !== my_ascensions())
			setProperty("autoSatisfyWithStorage", "false");
		// Yay! Get rid of the excess inventory!
		success = ocd_inventory(StopForMissingItems && !getvar("BaleOCD_MallDangerously").toBoolean());
	} finally { // Ensure properties are restored, even if the user aborted execution
		if(autoSatisfyWithCloset)  setProperty("autoSatisfyWithCloset", "true");
		if(autoSatisfyWithStorage) setProperty("autoSatisfyWithStorage", "true");
		if(autoSatisfyWithStash) setProperty("autoSatisfyWithStash", "true");
	}
	print("");
	return success? FinalSale: -1;
}