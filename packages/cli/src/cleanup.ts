import { CleanupAction, CleanupRule, CleanupRuleset } from "@philter/common";
import { loadCleanupRulesetFile, toItemMap } from "@philter/common/kol";
import { abort, autosell, autosellPrice, availableAmount, batchClose, batchOpen, canInteract, cliExecute, closetAmount, count, creatableAmount, create, equip, equippedAmount, getInventory, getProperty, haveDisplay, historicalAge, historicalPrice, isInteger, isOnline, isTradeable, itemAmount, mallPrice, max, min, myName, myPath, print, retrieveItem, setProperty, storageAmount, toBoolean, toItem, use, userConfirm } from "kolmafia";
import {getvar, kmail, rnum, vprint} from 'zlib.ash';
import { countIngredient, fullAmount, get_malus_order, is_OCDable, split_items_sorted } from "./util";


/**
 * Loads cleanup rules from the player's cleanup ruleset file into a map.
 * This will look for a ruleset file whose name is stored in the
 * `BaleOCD_DataFile` property. If this fails, it uses the current player's name
 * as a fallback.
 *
 * @param extraRulesetFile If this is not an empty string, this specifies the
 * 			name of the text file (without the ".txt") to load extra cleanup rules
 * 			from.
 *      These cleanup rules will be merged with the user's ruleset, with the
 * 			user's rules taking priority.
 * @return The loaded and combined cleanup ruleset
 */
	function load_OCD(extraRulesetFile?: string) {
	const cleanupRules = loadCleanupRulesetFile(`OCDdata_${getvar("BaleOCD_DataFile")}.txt`) || loadCleanupRulesetFile(`OCD_${myName()}_Data.txt`)
	if (
		!cleanupRules
	) {
		throw new Error("Something went wrong trying to load OCDdata!");
	}

	if (extraRulesetFile) {
		// Merge extra cleanup ruleset
		const extraCleanupRules = loadCleanupRulesetFile(`${extraRulesetFile}.txt`);
		if (extraCleanupRules) {
			for (const [item, rule] of extraCleanupRules) {
				if (!cleanupRules.has(item)) cleanupRules.set(item, rule);
			}
		}
	}

	if (cleanupRules.size === 0) {
		throw new Error("All item information is corrupted or missing. Whoooah! I hope you didn't lose any data...");
	}
	return cleanupRules;
}

/**
 * Sale price cache for the MALL action.
 * This cache is populated by `print_cat()` with values returned by
 * `sale_price()`. Later, it is accessed by `act_cat()`. This ensures that the
 * sale price displayed to the user matches the actual sale price used.
 * Note that this cache is never used when sending items to a mall multi.
*/
const price = new Map<Item, number>();


/**
 * Computes an appropriate selling price for an item at the mall, based on its
 * current (or historical) mall price.
 * @param it Item to check
 * @param minPrice Minimum price
 * @return Appropriate selling price for the item, or zero if the item is not
 *		available in the mall.
 *		The returned price is guaranteed to be at least 0.
 */
function sale_price(it: Item, minPrice: number): number {
	let price = 0;
	if(historicalAge(it) < 1 && historicalPrice(it) > 0)
		price = historicalPrice(it);
	else price = mallPrice(it);
	return Math.max(minPrice, price, 0);
}

// Amount to OCD. Consider equipment in terrarium (but not equipped) as OCDable.
function ocd_amount(it: Item, action: CleanupAction, keepAmount: number, stock): number {
	if(action === "KEEP") return 0;
	const full = fullAmount(it);
	// Unequip item from terrarium or equipment if necessary to OCD it.
	if(full > keepAmount && availableAmount(it) > itemAmount(it))
		retrieveItem(Math.min(full - keepAmount, availableAmount(it)), it);
	// Don't OCD items that are part of stock. Stock can always be satisfied by closet.
	const keep = getvar("BaleOCD_Stock") === "0" ? keepAmount:
		Math.max(keepAmount, stock[it].q - (getProperty("autoSatisfyWithCloset") === "false"? 0: closetAmount(it)));
	// OCD is limited by itemAmount(it) since we don't want to purchase anything and closeted items
	// may be off-limit, but if there's something in the closet, it counts against the amount you own.
	return Math.min(full - keep, itemAmount(it));
}

	/**
	 * Cleanup execution plan generated by examining OCD data and the player's
	 * inventory, closet, storage, etc.
	 */
	 interface CleanupPlan {
		/** Items to break apart. */
		 brak: Map<Item, number>;
		/** Items to transform into other items. */
		 make: Map<Item, number>;
		/** Items to untinker. */
		 untink: Map<Item, number>;
		/** Items to use. */
		 usex: Map<Item, number>;
		/** Items to pulverize. */
		 mall: Map<Item, number>;
		/** Items to autosell. */
		 auto: Map<Item, number>;
		/** Items to discard. */
		 disc: Map<Item, number>;
		/** Items to put in the display case. */
		 disp: Map<Item, number>;
		/** Items to put in the closet. */
		 clst: Map<Item, number>;
		/** Items to put in the clan stash. */
		 clan: Map<Item, number>;
		/** Items to display reminder message(s). */
		 todo: Map<Item, number>;
		/**
		 * Items to send to another player.
		 * Maps target player name => item => quantity.
		 */
		gift: Map<string, Map<Item, number>>;

		/**
		 * Intermediate cache that stores how many of an item is consumed by a
		 * transformation recipe ("MAKE" action).
		 * For example, if the OCD action for the 'bar skin' is "MAKE" and the
		 * target item is a 'barskin tent', then this map will contain
		 * 'bar skin' => 1. If the OCD configuration for the 'spider web' is
		 * "MAKE" and the target item is a 'really really sticky spider web',
		 * then this map will contain 'spider web' => 4.
		 */
		make_q: Map<Item, number>;
	};


	/**
	 * Process all malusable items with the `PULV` action.
	 * This assumes that the player can use the Malus.
	 * @param ocd_rules OCD ruleset to use
	 * @return Whether any item was actually processed
	 *      (i.e. whether any OCD plans must be evaluated again)
	 */
	 function malus(cleanupRules: Map<Item, CleanupRule>): boolean {

		let has_processed_any = false;

		// Process each malus order sequentially.
		// This allows us to process malus products that can be malused again,
		// e.g. powders -> nuggets -> wads.
		for (let malus_order = 1; malus_order <= 3; ++malus_order) {
			// Gather items to be malused
			const items_to_malus = new Map<Item, number>();
			for (const [it, rule] of cleanupRules) {
				if (rule.action !== "PULV") continue;
				// This also filters out non-malusable items
				if (get_malus_order(it) !== malus_order) continue;

				let amount = ocd_amount(it, "PULV", rule.keepAmount || 0);
				// The Malus always converts items in multiples of 5
				amount -= amount % 5;
				if (amount < 1) continue;
				items_to_malus.set(it, amount);
			}

			// Malus the gathered items
			for (const chunk of split_items_sorted(items_to_malus, 11)) {
				const tokens: string[] = [];
				const tokens_shown: string[] = [];
				for (const [it, amount] of chunk) {
					tokens.push(`${amount} \u00B6{it.to_int()}`);
					tokens_shown.push(`${amount} ${it.name}`);
				}

				vprint(
					`pulverize ${tokens_shown.join(", ")}`, _ocd_color_info(), 3
				);
				vprint(" ", 3);
				if (!toBoolean(getvar("BaleOCD_Sim"))) {
					cliExecute(`pulverize ${tokens.join(", ")}`);
				}
				has_processed_any = true;
			}
		}

		return has_processed_any;
	}


	/**
	 * Sends all items with the `PULV` action to a pulverizing bot.
	 *
	 * Note: Multi-level malusing (i.e. converting powders directly to wads) is
	 * not guaranteed to work. Because only 11 items can be sent per each kmail,
	 * some malus products may not be processed.
	 * @param ocd_rules OCD ruleset to use
	 * @return Whether any item was actually sent
	 */
	 function send_to_pulverizing_bot(ocd_rules: ReadonlyMap<Item, CleanupRule>): boolean {
		const items_to_send = new Map<Item, number>();
		for (const [it, rule] of ocd_rules) {
			if (rule.action !== "PULV") continue;
			if (!isTradeable(it)) {
				vprint(
					`send_to_pulverizing_bot(): Skipping {it} since it cannot be traded`,
					_ocd_color_debug(),
					10
				);
				continue;
			}

			const amount = ocd_amount(it, "PULV", rule.keepAmount || 0);
			// Note: Always send malusable items even if the quantity is not a
			// multiple of 5.
			// For example, we should be able to send 5 powders and 4 nuggets,
			// so that the bot can combine them into 1 wad.
			if (amount < 1) continue;
			items_to_send.set(it, amount);
		}

		if (items_to_send.size === 0) {
			vprint("Nothing to pulverize after all.", _ocd_color_info(), 3);
			return false;
		}

		if (!canInteract()) {
			// Because Smashbot cannot return items to characters in
			// Ronin/Hardcore, any items
			vprint(
				"You cannot send items to Smashbot while in Ronin/Hardcore.",
				_ocd_color_info(),
				-3
			);
			return false;
		} else if (!isOnline("smashbot")) {
			vprint(
				"Smashbot is offline! Pulverizables will not be sent at this time, just in case.",
				_ocd_color_warning(),
				-3
			);
			return false;
		} else {
			// Smashbot supports fine-grained malus control through the
			// "goose_level" command.
			// TODO: Find out if Smashbot supports floaty sand/pebbles/gravel
			const ITEM_GOOSE_LEVELS = new Map<Item, number>([
				[Item.get('twinkly powder'), 1],
				[Item.get('hot powder'), 2],
				[Item.get('cold powder'), 4],
				[Item.get('spooky powder'), 8],
				[Item.get('stench powder'), 16],
				[Item.get('sleaze powder'), 32],
				[Item.get('twinkly nuggets'), 64],
				[Item.get('hot nuggets'), 128],
				[Item.get('cold nuggets'), 256],
				[Item.get('spooky nuggets'), 512],
				[Item.get('stench nuggets'), 1024],
				[Item.get('sleaze nuggets'), 2048],
			]);
			let goose_level = 0;
			for (const [it, it_goose_level] of ITEM_GOOSE_LEVELS) {
				if (items_to_send.has(it)) {
					goose_level |= it_goose_level;
				}
			}
			let message = `goose_level ${goose_level}`;

			// Smashbot supports a single command ("rock" to malus all the way
			// up to floaty rock) for multi-malusing floaty items.
			// Since this is not sophisticated enough for all our needs,
			// we should identify and warn about cases where neither "rock" nor
			// the default behavior (no "rock") would satisfy our requirements.
			let can_use_rock = false;
			let should_warn_rerun = false;
			if (
				items_to_send .has(Item.get('floaty sand')) &&
				ocd_rules.get(Item.get('floaty pebbles'))?.action === "PULV"
			) {
				// Default behavior:
				//  sand -> pebbles (stop)
				// With "rock":
				//  sand -> pebbles -> gravel -> rock
				if (ocd_rules.get(Item.get('floaty gravel'))?.action === "PULV") {
					can_use_rock = true;
				} else {
					should_warn_rerun = true;
				}
			} else if (
				items_to_send.has(Item.get('floaty pebbles')) &&
				ocd_rules.get(Item.get('floaty gravel'))?.action === "PULV"
			) {
				// Default behavior:
				//  pebbles -> gravel (stop)
				// With "rock":
				//  pebbles -> gravel -> rock
				can_use_rock = true;
			}

			if (should_warn_rerun) {
				vprint(
					"Note: Smashbot cannot malus floaty sand to gravel in a single kmail." +
					" OCD-Cleanup will convert the pebbles to gravel when you run it again.",
					_ocd_color_warning(),
					3
				);
			}
			if (can_use_rock) {
				message += '\nrock';
			}

			vprint("Sending pulverizables to: Smashbot", _ocd_color_info(), 3);
			kmail("smashbot", message, 0, items_to_send);
			return true;
		}
	}

// StopForMissingItems is a parameter in case someone wants to include this script.
// StopForMissingItems = FALSE to prevent a pop-up confirmation.
export function ocd_control(shouldStopForMissingItems: boolean, extraData = '') {
	let FinalSale = 0;

	record {
		string type;
		int q;
	} [item] stock;

	// Save these so they can be screwed with safely
	let autoSatisfyWithCloset = toBoolean(getProperty("autoSatisfyWithCloset"));
	let autoSatisfyWithStorage = toBoolean(getProperty("autoSatisfyWithStorage"));
	let autoSatisfyWithStash = toBoolean(getProperty("autoSatisfyWithStash"));

	let use_multi = getvar("BaleOCD_MallMulti") !== "" && toBoolean(getvar("BaleOCD_UseMallMulti"));

	const command = Object.freeze({
		BREAK:  "break apart ",
MAKE:  "transform ",
UNTN:  "untinker ",
USE:  "use ",
PULV:  "pulverize ", // Not used, "pulverize" is hardcoded now
MALL: use_multi ?  `send to mallmulti ${getvar("BaleOCD_MallMulti")}: ` : "mallsell ",
AUTO:  "autosell ",
DISC:  "discard ",
DISP:  "display ",
CLST:  "closet ",
CLAN:  "stash put ",
GIFT:  "send gift to ",
	});

	/**
	 * Once this has been set to `false`, it will be `false` for all successive
	 * calls to the function
	 */
	let AskUser = true;

	/**
	 * Examines the inventory and generates an appropriate execution plan.
	 * If it finds uncategorized items in inventory, it asks the user whether it
	 * should abort. If the user answers "No", it will not ask the user again
	 * within the current `ocd_control()` call.
	 * @param StopForMissingItems If `false`, this function will never ask for
	 *      confirmation to proceed, even if there are uncategorized items.
	 * @param ocd_rules Map containing OCD rules
	 * @return `true` if the user chose to continue, or was not asked at all
	 *      (i.e. there were no uncategorized items).
	 *      `false` if the user chose to abort.
	 */
	function make_plan(
		StopForMissingItems: boolean, cleanupRules: ReadonlyMap<Item, CleanupRule>
	): CleanupPlan | null {
		AskUser = AskUser && StopForMissingItems;
		// Don't stop if "don't ask user" or it is a quest item, or it is being stocked.
		function stop_for_relay(doodad: Item): boolean {
			if(!AskUser || !is_OCDable(doodad) || (stock contains doodad && fullAmount(doodad) <= stock[doodad].q))
				return false;
			if(userConfirm("Uncategorized item(s) have been found in inventory.\nAbort to categorize those items with the relay script?")) {
				throw new Error("Please use the relay script to categorize missing items in inventory.");
			}
			AskUser = false;
			return false;
		}

		const plan: CleanupPlan = {
			 brak: new Map<Item, number>(),
			 make: new Map<Item, number>(),
			 untink: new Map<Item, number>(),
			 usex: new Map<Item, number>(),
			 mall: new Map<Item, number>(),
			 auto: new Map<Item, number>(),
			 disc: new Map<Item, number>(),
			 disp: new Map<Item, number>(),
			 clst: new Map<Item, number>(),
			 clan: new Map<Item, number>(),
			 todo: new Map<Item, number>(),
			gift: new Map<string, Map<Item, number>>(),
			make_q: new Map<Item, number>()
		};

		let excess = 0;
		for (const doodad of toItemMap(getInventory()).keys()) {
			const rule = cleanupRules.get(doodad);
			if(rule) {
				excess = ocd_amount(doodad, rule.action, rule.keepAmount);
				if(excess > 0)
					switch(rule.action) {
					case "BREAK":
						plan.brak.set(doodad, excess);
						break;
					case "MAKE": {
						const target = toItem(rule.targetItem);
						const used_per_craft = countIngredient(doodad, target
						);
						plan.make_q.set(doodad, used_per_craft);
						if (used_per_craft === 0) {
							vprint(
								`You cannot transform an ${doodad} into a ${rule.targetItem}. There's a problem with your data file or your crafting ability.`,
								_ocd_color_error(),
								-3
							);
							break;
						}
						let use_qty = excess;
						if (used_per_craft > 1) {
							use_qty = use_qty - (use_qty % used_per_craft);
						}

						if (rule.shouldUseCreatableOnly) {
							use_qty = min(
								use_qty,
								creatableAmount(target) * used_per_craft
							);
						}
						if (use_qty !== 0) plan.make.set(doodad, use_qty);
						break;
					}
					case "UNTN":
						plan.untink.set(doodad, excess);
						break;
					case "USE":
						if(myPath() === "Bees Hate You" && doodad.name.includes("b"))
							break;
						plan.usex.set(doodad, excess);
						break;
					case "PULV":
						// No-op since act_pulverize() does its own logging
						break;
					case "MALL":
						plan.mall.set(doodad, excess);
						break;
					case "AUTO":
						plan.auto.set(doodad, excess);
						break;
					case "DISC":
						plan.disc.set(doodad, excess);
						break;
					case "DISP":
						if(haveDisplay())
							plan.disp.set(doodad, excess);
						// else KEEP
						break;
					case "CLST":
						plan.clst.set(doodad, excess);
						break;
					case "CLAN":
						plan.clan.set(doodad, excess);
						break;
					case "GIFT":{
						let giftMap = plan.gift.get(rule.recipent);
						if (!giftMap) {
							plan.gift.set(rule.recipent, giftMap = new Map());
						}
						giftMap.set(doodad, excess);
						break;}
					case "TODO":
						plan.todo.set(doodad, excess);
						break;
					case "KEEP":
						break;
					default:
						if(stop_for_relay(doodad))
							return null;
					}
			} else {
				if(stop_for_relay(doodad))
					return null;
				// Potentially disasterous, but this will cause the script to sell off unlisted items, just like it used to.
				if(toBoolean(getvar("BaleOCD_MallDangerously")))
					plan.mall.set(doodad, excess);   // Backwards compatibility FTW!
			}
		}
		return plan;
	}

	function print_cat(cat: ReadonlyMap<Item, number>, rule: CleanupRule, cleanupRules: ReadonlyMap<Item, CleanupRule>): void {
		if(count(cat) < 1) return;

		const catOrder = new Map(Array.from(cat).sort(([itemA], [itemB]) => itemA.name.localeCompare(itemB.name)));

		let len = 0, total = 0, linevalue = 0;
		let queue = '';

		if (rule.action === 'KEEP' || rule.action === 'TODO') {throw new Error(`print_cat cannot process "${rule.action}" rule`);}
		let com = command[rule.action];
		if(rule.action === "GIFT") com += `${rule.recipent}: `;
		function print_line(): boolean {
			vprint(com + queue, _ocd_color_info(), 3);
			if (rule.action === "MALL"){
				vprint(`Sale price for this line: ${rnum(linevalue)}`, _ocd_color_info(), 3);
			}
			vprint(" ", 3);
			len = 0;
			total += linevalue;
			linevalue = 0;
			queue = ''
			return true;
		}

		for (const [it, quant] of catOrder) {
			if(it === Item.get(`Degrassi Knoll shopping list`) && itemAmount(Item.get(`bitchin' meatcar`)) === 0){
				continue;}
			if(len !== 0)
				queue+=(", ");
			queue+=(`${quant} ${it}`);
			if(rule.action === "MALL") {
				if(!use_multi) {
					price.set(it, sale_price(it, rule.minPrice));
					if(getvar("BaleOCD_Pricing") === "auto"){
						queue += ` @ ${rnum(price.get(it) || 0)}`;}
				}
				linevalue += quant * (price.get(it) || 0);
			} else if(rule.action === "MAKE") {
				queue += ` into ${rule.targetItem}`;
			} else if(rule.action === "AUTO") {
				linevalue += quant * autosellPrice(it);
			}
			len = len + 1;
			if(len === 11)
				print_line();
		}
		if(len > 0)
			print_line();

		if(rule.action === "MALL") {
			if(!use_multi){
				vprint(`Total mall sale = ${rnum(total)}`,_ocd_color_info(), 3);}
			// else vprint("Current mall price = "+rnum(total), _ocd_color_info(), 3);
		} else if(rule.action === "AUTO"){
			vprint("Total autosale = "+rnum(total), _ocd_color_info(), 3);}
		FinalSale += total;
	}

	// This is only called if the player has both kinds of clovers, so no need to check if stock contains both
	function clovers_needed(): boolean {
		return stock[Item.get(`ten-leaf clover`)].q + stock[Item.get(`disassembled clover`)].q
		  - fullAmount(Item.get(`ten-leaf clover`)) - fullAmount(Item.get(`disassembled clover`));
	}

	/**
	 * Stocks up on items based on the stock rules.
	 * @param ocd_rules OCD ruleset to use
	 * @return Whether all items were stocked successfully
	 */
	boolean stock(OCDinfo [item] ocd_rules) {
		boolean success = true;
		boolean first = true;
		boolean stockit(int q, item it) {
			q = q - closetAmount(it) - storageAmount(it) - equippedAmount(it);
			if(q < 1) return true;
			if(first) first = !vprint("Stocking up on required items!", _ocd_color_info(), 3);
			return retrieveItem(q, it);
		}

		batchOpen();
		foreach it in stock {
			// Someone might want both assembled and disassembled clovers. Esure there are enough of combined tot
			if(Item.get(['ten-leaf clover','disassembled clover']).includes(it) && stock contains other_clover(it)
			   && clovers_needed() > 0)
				cliExecute("cheapest ten-leaf clover, disassembled clover; acquire "
				  + to_string(clovers_needed() - availableAmount(it)) +" it");
			if(fullAmount(it) < stock[it].q && !stockit(stock[it].q, it)) {
				success = false;
				print("Failed to stock "+(stock[it].q > 1? stock[it].q + " "+ it.plural: "a "+it), _ocd_color_error());
			}
			// Closet everything (except for gear) that is stocked so it won't get accidentally used.
			if(it.to_slot() === $slot[none] && stock[it].q - ocd_rules[it].q > closetAmount(it) && itemAmount(it) > ocd_rules[it].q)
				put_closet(min(itemAmount(it) - ocd_rules[it].q, stock[it].q - ocd_rules[it].q - closetAmount(it)), it);
			// If you got clovers, closet them before they get protected into disassembled clovers.
			//if(it === Item.get(`ten-leaf clover`) && toBoolean(getProperty("cloverProtectActive")))
			//	put_closet(itemAmount(it), it);
		}
		batchClose();
		return success;
	}

	/**
	 * Ppulverize and malus all items with the `PULV` action.
	 * @param ocd_rules OCD ruleset to use
	 * @return Whether any item was actually processed
	 *      (i.e. whether any OCD plans must be evaluated again)
	 */
	boolean act_pulverize(OCDinfo [item] ocd_rules) {
		/**
		 * Checks if an item can be pulverized.
		 */
		boolean is_pulverizable(item it) {
			switch (it) {
			// Workaround for some items incorrectly marked as Pulverizable
			case Item.get(` Eight Days a Week Pill Keeper `):
			case Item.get(` Powerful Glove `):
			case Item.get(` Guzzlr tablet `):
			case Item.get(` Iunion Crown `):
			case Item.get(` Cargo Cultist Shorts `):
			case Item.get(` unwrapped knock-off retro superhero cape `):
				return true;
			}

			return get_related(it, "pulverize").count() > 0;
		}

		/**
		 * Checks if the current player can use the Malus.
		 */
		boolean can_use_malus() {
			return have_skill(Skill.get('Pulverize')) &&
				my_primestat() === $stat[ muscle ];
		}

		if (!have_skill($skill[ Pulverize ])) {
			return send_to_pulverizing_bot(ocd_rules);
		}

		boolean has_processed_any;

		// Process all pulverizable items first, so that we can malus the
		// powders/nuggets/wads gained from pulverizing.

		int [item] items_to_smash;
		foreach it, rule in ocd_rules {
			if (rule.action !== "PULV") continue;
			if (!is_pulverizable(it)) continue;

			int amount = ocd_amount(it, "PULV", rule.q);
			if (amount < 1) continue;
			items_to_smash[it] = amount;
		}

		item [int, int] chunks = split_items_sorted(items_to_smash, 11);
		foreach chunk_index in chunks {
			string [int] tokens, tokens_shown;
			foreach _, it in chunks[chunk_index] {
				int amount = items_to_smash[it];
				tokens[tokens.count()] = `{amount} \u00B6{it.to_int()}`;
				tokens_shown[tokens_shown.count()] = `{amount} {it.name}`;
			}

			vprint(`pulverize {tokens_shown.join(", ")}`, _ocd_color_info(), 3);
			vprint(" ", 3);
			if (!getvar("BaleOCD_Sim").toBoolean()) {
				cliExecute(`pulverize {tokens.join(", ")}`);
			}
			has_processed_any = true;
		}

		// Malus all items, including those gained from pulverizing.
		if (can_use_malus()) {
			if (malus(ocd_rules)) has_processed_any = true;
		} else {
			if (send_to_pulverizing_bot(ocd_rules)) {
				has_processed_any = true;
			}
		}

		return has_processed_any;
	}

	int sauce_mult(item itm) {
		if(my_class() === $class[sauceror])
			switch(itm) {
			case Item.get(`philter of phorce`):
			case Item.get(`Frogade`):
			case Item.get(`potion of potency`):
			case Item.get(`oil of stability`):
			case Item.get(`ointment of the occult`):
			case Item.get(`salamander slurry`):
			case Item.get(`cordial of concentration`):
			case Item.get(`oil of expertise`):
			case Item.get(`serum of sarcasm`):
			case Item.get(`eyedrops of newt`):
			case Item.get(`eyedrops of the ermine`):
			case Item.get(`oil of slipperiness`):
			case Item.get(`tomato juice of powerful power`):
			case Item.get(`banana smoothie`):
			case Item.get(`perfume of prejudice`):
			case Item.get(`libation of liveliness`):
			case Item.get(`milk of magnesium`):
			case Item.get(`papotion of papower`):
			case Item.get(`oil of oiliness`):
			case Item.get(`cranberry cordial`):
			case Item.get(`concoction of clumsiness`):
			case Item.get(`phial of hotness`):
			case Item.get(`phial of coldness`):
			case Item.get(`phial of stench`):
			case Item.get(`phial of spookiness`):
			case Item.get(`phial of sleaziness`):
			case Item.get(`Ferrigno's Elixir of Power`):
			case Item.get(`potent potion of potency`):
			case Item.get(`plum lozenge`):
			case Item.get(`Hawking's Elixir of Brilliance`):
			case Item.get(`concentrated cordial of concentration`):
			case Item.get(`pear lozenge`):
			case Item.get(`Connery's Elixir of Audacity`):
			case Item.get(`eyedrops of the ocelot`):
			case Item.get(`peach lozenge`):
			case Item.get(`cologne of contempt`):
			case Item.get(`potion of temporary gr8ness`):
			case Item.get(`blackberry polite`):
				return 3;
			}
		return 1;
	}

	boolean create_it(item it, item obj, int quant, int make_quant) {
		if (make_quant === 0) return false;
		quant = quant / make_quant * sauce_mult(it);
		if(quant > 0) return create(quant, obj);
		return false;
	}

	boolean use_it(int quant, item it) {
		boolean use_map(item required) {
			cliExecute("checkpoint");
			if(required === Item.get(`none`))
				cliExecute("maximize stench resistance, 1 min");
			else {
				retrieveItem(1, required);
				equip(required);
			}
			boolean success = use(1, it);
			cliExecute("outfit checkpoint");
			return success;
		}
		switch(it) {
		case Item.get(`the Slug Lord's map`):
			return use_map(Item.get(`none`));
		case Item.get(`Dr. Hobo's map`):
			item whip = Item.get(`cool whip`);
			foreach it in $items[Bar whip, Bat whip, Clown whip, Demon whip, Dishrag, Dreadlock whip, Gnauga hide whip,
			  Hippo whip, Palm-frond whip, Penguin whip, Rattail whip, Scorpion whip, Tail o' nine cats, White whip,
			  Wumpus-hair whip, Yak whip]
				if(itemAmount(it) > 0 && can_equip(it)) {
					whip = it;
					break;
				}
			retrieveItem(1, Item.get(`asparagus knife`));
			return use_map(whip);
		case Item.get(`Dolphin King's map`):
			item breather = Item.get(`snorkel`);
			foreach it in $items[aerated diving helmet, makeshift SCUBA gear]
				if(itemAmount(it) > 0 && can_equip(it)) {
					breather = it;
					break;
				}
			return use_map(breather);
		case Item.get(`Degrassi Knoll shopping list`):
			if(itemAmount(Item.get(`bitchin' meatcar`)) === 0)
				return false;
			break;
		}
		return use(quant, it);
	}

	string message(int [item] cat, OCDinfo [item] ocd_rules) {
		foreach key in cat
			return ocd_rules[key].message;
		return "";
	}

	/**
	 * Process a collection of items using a given action.
	 * @param cat Collection of items and their amounts to be processed
	 * @param act Item action ID
	 * @param Receiving player ID. Used for actions that involve another player
	 * 	  (e.g. "GIFT")
	 * @param plan OCD execution plan being used
	 * @param ocd_rules Map containing OCD rules
	 * @return Boolean that indicates whether the execution plan must be
	 *    regenerated before processing another action.
	 */
	boolean act_cat(
		int [item] cat,
		string act,
		string to,
		OcdPlan plan,
		OCDinfo [item] ocd_rules
	) {

		item [int] catOrder;
		foreach it in cat
			catOrder[ count(catOrder) ] = it;
		sort catOrder by to_lower_case(to_string(value));

		// If there are no items to process, we don't need to regenerate the
		// execution plan.
		if(count(cat) === 0) return false;
		int i = 0;
		if (act === "TODO" && count(cat) > 0)
			print("");
		else if (act === "PULV")
			abort("PULV action must be handled by act_pulverize()");
		else
			print_cat(cat, act, to, ocd_rules);
		if(getvar("BaleOCD_Sim").toBoolean()) return true;
		switch(act) {
		case "MALL":
			if (use_multi) {
				string multi_id = getvar("BaleOCD_MallMulti");
				string multi_message = getvar("BaleOCD_MultiMessage");

				// Some users have reported OCD-Cleanup occasionally sending
				// items to an account named "False". While the exact cause is
				// unknown, this should serve as a stopgap measure.
				if (multi_id === "" || multi_id.to_lower_case() === "false") {
					print(
						`Invalid mall multi account ID ("{multi_id}"). Please report the issue at https://kolmafia.us/`,
						_ocd_color_error()
					);
					int timeout = 30;
					string warning_message =
						`OCD-Cleanup has detected that it is about to send items to a mall multi account named "{multi_id}". ` +
						`Since this is likely an error, OCD-Cleanup will NOT send the items.\n\n` +
						`Do you want to abort OCD-Cleanup immediately?\n` +
						`(If you choose "No" or wait {timeout} seconds, OCD-Cleanup will skip the MALL action and continue.)`;
					// If the user disables userConfirm() -- possibly because
					// they are calling OCD-Cleanup from an auto-adventuring
					// script -- it will always return false.
					// In this case, we will continue processing instead of
					// aborting (which would otherwise be disruptive).
					if (userConfirm(warning_message, timeout * 1000, false)) {
						abort(`You decided to abort OCD-Cleanup.`);
					}
					print(`OCD-Cleanup has skipped the MALL action.`);
					return false;
				} else {
					return kmail(multi_id, multi_message, 0, cat);
				}
			}
		case "AUTO":
		case "DISP":
		case "CLST":
		case "CLAN":
			batchOpen();
			break;
		case "GIFT":
			string message = message(cat, ocd_rules);
			return kmail(to, message, 0, cat, message);
		case "KBAY":
			// This should be unreachable
			abort("KBAY action is no longer available");
		}
		foreach x, it in catOrder {
			int quant = cat[it];
			switch(act) {
			case "BREAK":
				for i from 1 to quant
					visit_url("inventory.php?action=breakbricko&pwd&ajax=1&whichitem="+to_int(it));
				break;
			case "MALL":
				if(getvar("BaleOCD_Pricing") === "auto") {
					if(price[it]> 0)  // If price is -1, then there was an error.
						put_shop(price[it], 0, quant, it);  // price[it] was found during print_cat()
				} else
					put_shop((shop_amount(it)>0? shop_price(it): 0), 0, quant, it);   // Set to max price of 999,999,999 meat
				break;
			case "AUTO":
				autosell(quant, it);
				break;
			case "DISC":
				for i from 1 to quant {
					if(i % 10 === 0)
						print("Discarding "+i+" of "+quant+"...");
					visit_url("inventory.php?action=discard&pwd&ajax=1&whichitem="+to_int(it));
				}
				break;
			case "USE":
				use_it(quant, it);
				break;
			case "MAKE":
				create_it(
					it, to_item(ocd_rules[it].info), quant, plan.make_q[it]
				);
				break;
			case "UNTN":
				cliExecute("untinker "+quant+" \u00B6"+ it.to_int());
				break;
			case "DISP":
				put_display(quant, it);
				break;
			case "CLST":
				put_closet(quant, it);
				break;
			case "CLAN":
				put_stash(quant, it);
				break;
			case "TODO":
				print_html("<b>"+it+" ("+quant+"): "+ocd_rules[it].info+"</b>");
				break;
			}
			i += 1;
			// If there are too many items batched mafia may run out of memory. On poor systems it usually happens around 20 transfers so stop at 15.
			if(i >= 165 && (act === "MALL" || act === "AUTO" || act === "DISP" || act === "CLST" || act === "CLAN")) {
				batchClose();
				i = 0;
				batchOpen();
			}
		}
		if(act === "MALL" || act === "AUTO" || act === "DISP"|| act === "CLST" || act === "CLAN") batchClose();

		// It's okay to return true here, because ocd_inventory() only checks
		// this value for actions that can create or remove additional items.
		return true;
	}

	void unequip_familiars() {
		matcher unequip = create_matcher("<a href='(familiar.php\\?pwd=.+?&action=unequip&famid=(.+?))'>\\[unequip\\]"
			, visit_url("familiar.php"));
		while(unequip.find())
			switch(unequip.group(2)) {
			case "124": case "136": break;
			default:
				visit_url(unequip.group(1));
			}
	}

	boolean ocd_inventory(boolean StopForMissingItems) {
		OCDinfo [item] ocd_rules;
		if (!load_OCD(ocd_rules, extraData)) return false;
		if((!file_to_map("OCDstock_"+getvar("BaleOCD_StockFile")+".txt", stock) || count(stock) === 0)
		  && getvar("BaleOCD_Stock") === "1") {
			print("You are missing item stocking information.", _ocd_color_error());
			return false;
		}

		MakePlanResult mpr = make_plan(StopForMissingItems, ocd_rules);
		if (!mpr.success) return false;

		// Actions that may create additional items, or remove items not
		// included in the execution plan. If act_cat() returns true after
		// executing such actions, the entire execution plan must be regenerated
		// to handle such items correctly.
		if (act_cat(mpr.plan.brak, "BREAK", "", mpr.plan, ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}
		if (act_cat(mpr.plan.make, "MAKE", "", mpr.plan, ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}
		if (act_cat(mpr.plan.untink, "UNTN", "", mpr.plan, ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}
		if (act_cat(mpr.plan.usex, "USE", "", mpr.plan, ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}
		// Note: Since the next action (act_pulverize()) does its own planning,
		// the previous if-block does not need to call make_plan().
		// I'm only keeping it to make refactoring/reordering easier.
		if (act_pulverize(ocd_rules)) {
			mpr = make_plan(StopForMissingItems, ocd_rules);
			if (!mpr.success) return false;
		}

		// Actions that never create or remove additional items.
		// Currently, we do not bother to check the return value of act_cat()
		// for them.
		act_cat(mpr.plan.mall, "MALL", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.auto, "AUTO", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.disc, "DISC", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.disp, "DISP", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.clst, "CLST", "", mpr.plan, ocd_rules);
		act_cat(mpr.plan.clan, "CLAN", "", mpr.plan, ocd_rules);
		foreach person in mpr.plan.gift {
			act_cat(mpr.plan.gift[person], "GIFT", person, mpr.plan, ocd_rules);
		}

		if(getvar("BaleOCD_Stock") === "1" && !getvar("BaleOCD_Sim").toBoolean())
			stock(ocd_rules);

		act_cat(mpr.plan.todo, "TODO", "", mpr.plan, ocd_rules);

		if(getvar("BaleOCD_Sim").toBoolean())
			vprint(
				"This was only a test. Had this been an actual OCD incident your inventory would be clean right now.",
				_ocd_color_success(),
				3
			);
		return true;
	}

// *******  Finally, here is the main for ocd_control()
// int ocd_control(boolean StopForMissingItems) {

	cliExecute("inventory refresh");

	// Empty closet before emptying out Hangks, otherwise it may interfere with which Hangk's items go to closet
	if(to_int(getvar("BaleOCD_EmptyCloset")) >= 0 && getProperty("lastEmptiedStorage").to_int() !== my_ascensions()
	  && getvar("BaleOCD_Sim") === "false")
		empty_closet();

	// Empty out Hangks, so it can be accounted for by what follows.
	if(autoSatisfyWithStorage && getProperty("lastEmptiedStorage").to_int() !== my_ascensions())
		 visit_url("storage.php?action=pullall&pwd");

	boolean success;
	try {
		if(autoSatisfyWithCloset)
			setProperty("autoSatisfyWithCloset", "false");
		if(autoSatisfyWithStash)
			setProperty("autoSatisfyWithStash", "false");
		if(autoSatisfyWithStorage && getProperty("lastEmptiedStorage").to_int() !== my_ascensions())
			setProperty("autoSatisfyWithStorage", "false");
		// Yay! Get rid of the excess inventory!
		success = ocd_inventory(StopForMissingItems && !getvar("BaleOCD_MallDangerously").toBoolean());
	} finally { // Ensure properties are restored, even if the user aborted execution
		if(autoSatisfyWithCloset)  setProperty("autoSatisfyWithCloset", "true");
		if(autoSatisfyWithStorage) setProperty("autoSatisfyWithStorage", "true");
		if(autoSatisfyWithStash) setProperty("autoSatisfyWithStash", "true");
	}
	print("");
	return success? FinalSale: -1;
}